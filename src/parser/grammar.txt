program: item*
item: import | scope | main

main: "main" block-expression

import: "using" identifier ["." (import | import-group)] ";"
import-group: "{" import ("," import)* "}"

scope: "scope" identifier "{" scope-item* "}"
scope-item: contract | struct | func
contract: "contract" identifier "{" (function-prototype ";") "}"

struct: "struct" identifier ["requires" identifier*] "{" struct-body "}"
struct-body: (struct-member | struct-constructor)*
struct-member: ["public" | "private"] type identifier ["=" literal]
struct-constructor: identifier arguments block-expression

func: function-prototype "{" func-implementation* "}"
func-implementation: "on" identifier identifier block-expression
function-prototype: "func" identifier parameters "->" type
parameters: "(" [type identifier (type identifier ",")*] ")"

statement: block-expression | leave | declaration | putc
expression: block-expression | getc | alloc 
block-expression: loop | if | block | for | while
block: "{" statement* "}"
declaration: ("let" type identifier "=" expression | assignment) ";"
assignment: identifier "=" expression | inline-expression
constructor: ["new"] "$" identifier arguments
inline-expression: condition
for: "for" "(" declaration inline-expression ";" assignment ")" block
while: "while" inline-expression block
leave: "leave" [expression] ";"
loop: "loop" block
if: "if" inline-expression block elif* [else]
elif: "else" "if" inline-expression block
else: "else" block
alloc: "alloc" type ("[" inline-expression "]")+
condition: boolean-factor ("or" boolean-factor)*
boolean-factor: comparison ("and" comparison)*
comparison: arithmetic-term (comparator arithmetic-term)*
comparator: "<" | "<=" | "==" | "!=" | ">" | ">="
arithmetic-term: arithmetic-factor (("-" | "+") arithmetic-factor)*
arithmetic-factor: unary (("*" | "/") unary)*
unary: ("!" | "-")* call
call: [identifier arguments "@"]* inline-expression | primary
arguments: "(" [inline-expression (inline-expression ",")*] ")"
primary: var | literal | "(" inline-expression ")"
type: ["&"] (primitive-type | identifier) ("[]")*
primitive-type: "byte" | "char" | "int" | "long" | "float" | "double" | "bool" | "Self";
var: ["&"] identifier ("." identifier)* ("[" inline-expression "]")*

literal: string | character-literal | number | bool

string: """ (character | escape-sequence)* """
character-literal: "'" character "'"
escape-sequence: "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v" | "\'" | "\"" | "\\"
character: " " | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" | "," | "-" | "." | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" | "/" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~" | {"A"..."Z"} | {"a"..."z"} | {"0"..."9"} | escape-sequence

number: decimal | integer
decimal: ["-"] digit* ["." digit*] ["d"] | positive-integer "d"
bool: "true" | "false"
integer: ["-"] positive-integer ["i"]
nonnegative-integer: digit+
positive-integer: nonzero-digit digit*
identifier: alphabetic alpha-numeric*

alpha-numeric: alphabetic | digit
alphabetic: {"A"..."Z"} | {"a"..."z"} | "_"
digit = "0" | nonzero-digit
nonzero-digit: "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
